## 静态链接库和动态链接库

### 编译的过程
gcc/g++ 编译源文件所经历的四个步骤：预处理、编译、汇编和链接。

```c++
// 预处理
g++ -E xxx.cpp -o xxx.i

// 编译
g++ -S xxx.i -o xxx.s

// 汇编
g++ -c xxx.s -o xxx.o

// 链接
g++ xxx.o -o xxx

```
> 预处理

* 将所有的 #define 删除，并且展开所有的宏定义
* 处理所有的条件预编译指令，比如 #if、#ifdef、#elif、#else、#endif 等
* 处理 #include 预编译指令，将被包含的文件插入到该预编译指令的位置
* 删除所有注释 “//” 和 ”/* */”
* 添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号
* 保留所有的 #pragma 编译器指令，因为编译器需要使用它们

> 编译

编译过程 就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码。

> 汇编

汇编器 是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。

汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可。

> 链接

通过调用链接器 ld 来链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件。

链接的主要内容是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确地衔接。

### 静态链接和动态链接是什么

静态链接：在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。

动态链接：链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。

### 静态链接和动态链接的特点

静态链接：在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。

* 方便程序移植，可执行文件与库没有关系
* 可执行文件比较大

动态链接：优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝；缺点是由于是运行时加载，可能会影响程序的前期执行性能。

* 在内存中只存在一份拷贝，避免静态链接库浪费空间的问题
* 有利于进程间资源共享
* 可移植性差

### Linux 和 Windows 平台

Linux：静态链接库 lib*.a，动态链接库 lib*.so

Windows: 静态链接库 LIB，动态链接库 DLL

### 生成静态链接库和动态链接库

> 生成静态链接库

```
g++ -c *.cpp   // 编译生成 *.o 文件

ar crv libxxx.a *.o  // 归档目标文件，得到静态链接库，生成的库的文件名必须形如 libxxx.a

ar 命令的选项

* c 如果需要生成新的库文件，不要警告
* r 代替库中现有的文件或者插入新的文件
* v 输出详细信息
* t 可以查看静态库包含的文件
* s 无论 ar 命令是否修改了库内容，都强制重新生成库符号表

g++ -o main main.cpp -L. -lxxx  // 测试，在 main.cpp 中使用 libxxx.a 静态链接库，如果库文件与测试文件不在同一目录，需要 -L 包含库文件目录

-L. 告诉 gcc/g++ 搜索链接库时包含当前路径

-lxxx 告诉 gcc/g++ 生成可执行程序时要链接 libxxx.a

```

> 生成动态链接库

```
g++ -fIPC -shared -o libxxx.so *.cpp  // 生成了一个 libxxx.so 的动态链接库

* -fIPC：表示编译为位置独立的代码，用于编译共享库
* -shared：指定生成动态链接库

g++ -o main main.cpp -L. -lxxx  // 测试，在 main.cpp 中使用 libxxx.so 动态链接库，如果库文件与测试文件不在同一目录，需要 -L 包含库文件目录

测试程序找不到 libxxx.so 动态链接库时，需要在 /etc/ld.so.conf 文件中设置 动态链接库 的路径。
```

## 参考

* 《程序员的自我修养——链接、装载与库》
